[{"id":0,"href":"/docs/about/education/","title":"Education","section":"About Me","content":"Education "},{"id":1,"href":"/docs/about/publications/","title":"Publications","section":"About Me","content":"Publications "},{"id":2,"href":"/posts/cmdline-2019/","title":"My Command Line Solution Roundup - 2019","section":"Blog","content":"在这个时间节点上，还是稍微来整理下过去这一年以来在命令行工具方面的积累吧。过去的一年也是我在命令行中工作地越来越多的一年——中学的时候写了不少东西，学了不少操作，但是现在看来，其实都非常地扁平；随着项目规模的扩大，还是需要更好地工具来武装自己，提高效率。\n另外一点就是，有时候我们会觉得在图形环境下很容易工作，但在命令行环境下感到困难。所以我觉得一个比较有帮助的事情是，来整理一下我们如何使用一些图形的、集成的工具，从需求的角度出发，来整理命令行的使用技巧。\nHere we go!\nWhy Windows 往前两年特别痴迷于Linux环境，那时候觉得nautilus和gnome-terminal都是工作必备——我至今觉得nautilus是世界上最好的文件管理器，Linux上的Terminal选择范围也要大很多。但很遗憾，我的工作全部并不只是文件管理器和命令行，我还要上课，还要修图，还要摸鱼。所以，借着换新电脑的契机，我重新开始将Windows作为主要平台。\n Git for Windows是个非常好的工具，提供了SSH和Git这种基本工具，还提供了个Bash工具箱；当然，没啥扩展性。微软近年来也推出了WSL，不过细想还是有很多坑，比如WSL的API不健全，桥接的文件系统，糟糕的IO性能，以及操作上其他GUI工具如何使用WSL中的工具？尤其是如果涉及到SSH和Git，其中其实是有一些坑点的；这些都并非不能解决的问题，但都是需要解决的问题，所以我还是在用着Git Bash，用着Native的Python。但WSL也并非没有用处，我依赖WSL来作为Git Bash的补充，在里面查看manpage、安装编译器等工具。两者互为补充，在大部分时候已经可以替代Linux了，我还放了一个Xubuntu的虚拟机作为备用。\n关于文件系统，NTFS上当然不存在权限设置，但是实际使用中这并不是一件特别糟糕的事情，Git for Windows默认设置了权限不敏感，如果要设置一个文件的权限可以用update-index，而且大部分时候其实都是clone现有的repo，所以对Git来说没啥影响；反而，不要用WSL里的Git。软链的话，NTFS其实是支持的，可以在cmd里用mklink指令，而且Win10现在打开开发者模式就可以不需要管理员权限了。真正比较大的影响其实是路径大小写不敏感，放到NTFS上可能会出现路径相互覆盖。\n总之，NTFS是个麻烦，但现在都能绕开了，应该说赶上了MSYS成熟、WSL启动的好时代；Linux上有的工具确实是神一般的好用，但代价是另外有的工具几乎就不可用。mac么，早年有人说他兼具Windows与Linux之长，但实际上也是兼具两者之短，键盘和接口上的遗憾也是很大的问题。\nWhy Git Bash 关于Terminal的选择，我还是尝试了不少选择，最终最喜欢的还是Git for Windows自带的Git Bash (MinTTY)。简单，快速，功能齐全，除了没有标签页，没有什么好抱怨的。 MobaXterm也是个好东西，自带X Server，让我偶尔连集群图形不再需要Linux虚拟机或者x2go，但我对于启动速度并不怎么满意，其配置的眼花缭乱也令我敬而远之。对ConEmu的远离大抵也是因此，更何况我都没有把鼠标的问题解决出来。我也尝试过 hyper之类基于Electron的方案，在里面跑Git Bash的Shell，在解决了一些问题之后也还不错，但并不明显由于MinTTY吧。Windows Terminal初听觉得石破天惊，但是到现在仍然处于beta，也就不再提了。\n值得一提的是，我很喜欢 Termius，跨平台，可以同步（虽然我没有），而且还挺好看。不过在Windows客户端也没有标签页，虽然多窗口是有的，这本质上是个SSH客户端，但也可以执行本机shell，Git Bash是可以的，各种功能支持也还算健全。\n前面说过，Git Bash是一个很不错的工具箱。SSH命令行，能够支持端口转发之类的功能，能够自己控制自己的密钥；sed、awk等脚本神器；一个简单的vim。我一度通过Git Bash来做一些Windows管理的工作，比如打包配置文件，还写了一些成规模的Shell脚本，但当然，我现在还是都回归了Native Python来完成这些工作——更好的可维护性，更好的性能，还是很香的。\n更重要的一点是，Git Bash其实是个非常不错的Launcher。自带winpty，可以执行powershell和cmd，也可以安装 wslbridge，这个工具支持了广受赞誉的wsltty。\n我的Git Bash配置 我基本上是香草（vanilla）派，外观上没有做太多的定制，从功能上倒是做了些修改。Git Bash主要还是用来连SSH，所以定制也还是从这方面着手。\n开始入门SSH的时候基本上看的是GitHub的 手册，从生成密钥开始，后来又觉得明文密钥不安全，于是加上了口令。然而加入口令后麻烦其实真的不少：IDE里git不能用了，每次命令行连接也都要输密码，不过好歹每台服务器输的是同样的密码。\nGit Bash没有标签页也算是个问题。我也试过基于Electron的方案，比如VSCode，Termius之类的，接着就发现中文也不支持了，alias也不全了。检查了一下，发现是login shell的问题。于是我开始在.bashrc里source一些基本的profile。\n在这个过程中，发现了start-ssh-agent.cmd这么个脚本，自此开始折腾agent。想法很简单，开机启动agent，然后之后的ssh就都可以不用重复输密码了。但是Windows上不存在Login Shell，那环境变量该存在哪里呢？我试着用setx设Windows环境变量，效果很好，git也能够在VSCode里用了。但使用中还是有问题，经常会有智障清理软件把Socket File给删掉，这样的话agent就必须杀掉重新起；在VSCode里起起来的Git Bash会从Code继承旧的环境变量，结果还是会连不上agent。于是最近更新了一次，每次启动Git Bash都尝试启动agent，而且把环境存在一个文件中，这样每个子shell可以自己加载环境，不受继承的影响。\n另外我还做了一个基于.ssh/config的SSH Host补全。上述的这些功能我都放在 我的GitHub上了。\n我的Shell配置 早年还是用过 Oh My Zsh的，一开始觉得这东西好用又好看，然而回到Windows上，这就成了大坑。Git Bash里没带ZSH，那就用WSL吧；结果放在WSL上，严重拖慢启动速度。我最近回头看ZSH的配置，发现很多人其实都不推崇OMZ这个配置，认为Git Branch显示就是个坑。当然而且，Windows上的各个Terminal和其中的字体对于OMZ里用到的字符支持都不算好，这加速了我的退坑。\n以使用服务器为契机，我还是主要使用Bash了。作为香草派，我的PS1设置还是很简单的：以Debian的设置为基础，把全路径名换成了路径末端名。这样的话路径显示不会太长，而且不同的命令之间色彩上能看出来隔离。\n我对ZSH的特性利用还是比较局限，用的最多的就是上翻历史。当然，知道了Bash里的^r快捷键之后，我觉得Bash的体验也可以接受了。\n在调CESM的时候意识到，命令行用起来烦的一个很重要的原因是在不同的路径间切换很麻烦。ZSH在这方面的支持其实比较不错，但我当时因为没有需求并没有去了解。当然，有一些外部的工具，如autojump之类的，可以统计频率，局部匹配，自动跳转；但速度也是个问题，而且毕竟不原生。我另外用过的一个办法是mc——Midnight Commander这个文件管理器可以两个路径并排，并分别进入对应路径的Shell。好用是好用，但只能支持两个路径嘛，而且我有一次犯了糊涂进了嵌套mc，结果相当惨烈。\n也许这个需求可以用tmux来解决？然而工作区并不一定能够继续划分。我最近用得比较多的是Bash里的pushd功能，相当于是一个简易的标签页——这就和图形的操作比较像了。虽然手动了一点，但是方便和效率上都还是不输的。\n解决这个问题的另一种思路是模糊匹配工具——我在Vim里装上了fzf工具，就像IDE一样，也就不再需要在路径树里翻来翻去找文件了。\n我的tmux配置 一开始我觉得我对tmux的需求很简单，能用鼠标就行了。然而不同版本设置鼠标的命令还是不一样的。后来使用中又发现的一个问题：有的版本的tmux中，fork出来的pane会继承路径，有的则会又从头开始。这时候我开始感到迷惑——这个工具是真的不讲究后向兼容性啊，而且怎么还有新版本砍功能的情况。\n于是我开始去查能不能写多版本的配置文件，还真找到了。我现在用的配置文件是通过awk来解析和比较版本的，这种方式看网上用得不多，可能awk的兼容性会有问题？但可读性相对来说是非常好的，而且在我使用的几个平台上表现良好。\n最近发现同事很多都用 tony/tmux-config，于是也去试了一下，发现Windows上糟糕的Terminal色彩还是支撑不起这样的配置——所以默认配置是有默认配置的道理的。不过我还是去合并了一些功能性的配置，近来试用了一下，感觉舒服了不少。虽然都是些老生常谈的东西，但是还是再提一下吧：\n 用C-a作为prefix。虽然终极方案是把Ctrl和CapLocks换掉但是……先就这样吧。不过比较有趣的是，这个配置还设置了两下C-a切换窗口，活脱脱一个盗版screen。虽然很多人主张C-a用得比C-b少，但C-a可是经典emacs键位跳转到行首，直接封掉还是很可惜的；C-z、C-s之流就更令我感到困惑了。所以我还是用C-a，但是加了个send-prefix。 窗口编号从1开始。 窗口之间的切换可以用hjkl，比上下左右舒服了不少。 关于复制模式，虽然Vi模式应该更加的人类友好，但emacs键位意外地非常还原，出于练习emacs的目的可能会用一段时间；是的，Vi模式就不怎么还原，至少说不支持Vim中的v和y指令，抄来的配置中也修复了这个情况。  我的tmux配置也放在 GitHub上了。\n我的编辑器选择 随着在服务器上的工作越来越多、自己的虚拟机也不怎么撑得起VSCode的内存消耗，逐渐感到在服务器上高效编辑还是很重要的一门技能，而不是临时用用怎么样都行。当然，VSCode现在支持了远程编辑，这非常厉害，但另一方面是我发现，在tag系统的加持下，Vim的可用性一点不比Code差。\n我也从我的同事那里要来了他们的Vim配置，不过还没来得及细看。作为有一定练度的用户了，也已经不像初学者一样拿上一个配置就可以直接用，阅读与思考还是很重要。尤其是对于编辑器来说，这就是开发者工作的最重要的环境了，考虑清楚当中的需求还是非常重要的。\n关于Vim和Emacs之争，我是Vim老用户了，Emacs则是学了几次都没学会——有一说一，我觉得Emacs上手教程把退出放在最后讲是个败笔，一时半会没看完又连退出都不会，几次都气急败坏直接杀掉进程干别的事去了。但Emacs还是很重要，至少这套键位——虽然经常被认为是程序员工伤的罪魁祸首之一——使用的范围非常广泛。哪怕有人在Emacs里用Vim键位，在我对Emacs本身进一步产生兴趣之前，这都与我无关了。（有一说一Emacs调试好像厉害很多，有机会要试试）\n我在开始搭建我的Vim配置之前罗列了一下我现在觉得很需要的功能，Vim自带的有以下一些：\n 多标签、文件并排：众所周知(?) Vim是有Buffer功能的，但是开过的所有窗口都会进入Buffer，标签页在我看来则是一种显式的固定，应当是正交的。Vim有这方面的功能，但快捷键可能需要再配置下； 自动补全：因为目前看得多写得少，基本上自带的文本补全就够了； 代码的折叠、缩进、注释：然而还没有试用过相关的功能；  从一些现代编辑器中感到必要性的功能包括：\n 文件模糊匹配：我用了 fzf.vim，除了文件名还能搜很多别的东西，用处巨大； 多处编辑： vim-multiple-cursors基本够用，而且不需要怎么配置； 代码跳转：也是Vim中自带的Tag系统，但还需要一些外部工具的配合，接下来展开说；  要实现代码跳转，需要编辑器理解程序的语言吗？其实不怎么需要。有一类程序被称为*tags，则是通过简单的词法分析，从程序中提取定义的符号。这里面最经典的要数ctags (exuberant)，在项目目录里运行ctags -R .后会生成一个名为tags的文件，包含该项目中所有的符号和对应的位置。Vim能够读取tag文件中的信息，在有tag信息的目录下打开文件后，将光标移到一个引用的符号下，按下^]，就能够跳转到符号定义的位置。当然还有些别的功能，例如返回跳转前的位置、在新的标签或窗口中打开跳转。总之，这种看起来高级的功能，Vim其实是支持的，而且支持的语言相当多，只要ctags支持的都可以。\n当然这种外部程序的方法是会有一些痛点的，比如编辑之后需要手动重新索引，不支持增量更新的话重新索引一次可能会需要非常长的时间。还有一个问题是，ctags只能搜索定义，不能搜索引用。因此要用到cscope。这个程序使用逻辑和ctags差不多，也需要先新建索引，但其本身就是一个可以独立使用的交互式程序，可以在几种不同的类别下搜索符号，搜索的结果可以用Vim打开。当然，这个程序基本上就只支持C语言，而且每个结果的查看都在不同的的Vim窗口下。\nFind this C symbol: Find this function definition: Find functions called by this function: Find functions calling this function: Find this text string: Change this text string: Find this egrep pattern: Find this file: Find files #including this file: Find assignments to this symbol: cscope在Vim中使用上也要麻烦一些。需要先用:cs add \u0026lt;file\u0026gt;添加数据库，然后用:cs find \u0026lt;mode\u0026gt; \u0026lt;sym\u0026gt;进行搜索。虽然比ctags功能强，但好像并不能替代ctags；其实也有办法，可以设置:set cscopetag，这样定义跳转功能也可以不经ctags就使用了。\n另外一个值得提到的工具是gtags，或者叫GNU Global。gtags可以直接在目录里生成可增量更新的数据库文件，共计3个文件。相对来说比ctags是复杂了一些，但是gtags可以生成对引用的索引。gtags附带了一个global程序，可以用来对数据库进行检索——毕竟不同于ctags的索引文件，那个是文本形式的。为了在Vim中使用，gtags自带了一个Gtags.vim插件，不过并不支持前述的那套ctags的操作。\n总体来说gtags提供了比ctags和cscope都要好的性能，比cscope更好的语言兼容性，所能提供的功能至少和cscope相同，但是没有特别好的Vim接口。但是正因为gtags能够完成cscope的主要功能，gtags程序包也提供了一个gtags-cscope命令，通过cscope的操作方式和接口，以gtags为后端来完成检索。是的，可以用gtags-cscope来替代cscope，在Vim中设定:set cscopeprg=gtags-cscope即可。\n查找定义和查找引用在代码阅读中就算是比较典型的场景了，ctags和Vim的契合度是最好的，但是不支持查找引用；gtags则提供了更好的功能，通过cscope接口稍加配置使用体验也很不错，总比grep搜索要好。当然这里面还有些手动的过程，比如Tagfile的更新，cs add的调用，不过应该已经有相应的插件了。\n"},{"id":3,"href":"/posts/clang-no-opt/","title":"Clang: Don't Touch My Code!","section":"Blog","content":"Clang/LLVM is a toolchain that is widely adopted by both researchers and the industry. Based on LLVM, compilers for new targets are built, and program analysis solutions are developed, thanks to the well-defined LLVM IR. Nevertheless, Clang/LLVM is also famous for some of its strange (often just \u0026ldquo;different\u0026rdquo; from gcc) behaviors and very aggressive optimizations.\nRecently I am working on LLVM (7.0) for program analysis and instrumentation, and I think it\u0026rsquo;s time to write about how we are dealing with unwanted optimizations. Here we start.\nOur Problem We are doing a whole program analysis, thus we need to compile every source file to bitcode respectively, and then link them together to perform the analysis and instrumentation. Since there can be information loss during optimization, it\u0026rsquo;s best to analyze an untouched bitcode file, and then perform the optimization after instrumentation. Something like,\n$ clang -emit-llvm hello.c -c -o hello.bc $ opt -load mypass.so -mypassname hello.bc \u0026gt;output.bc $ clang -emit-llvm -O2 output.bc -o optimized.bc However, the latter optimization is not happening, i.e. output.bc and optmized.bc are nearly the same.\nHow is Clang calling optmizations? Suspecting some action might be done in the frontend, we looked into what clang is doing internally. The -### argument may be helpful.\n$ clang -\\#\\#\\# hello.c -O2 -c -o hello.bc -emit-llvm clang version 7.0.0 Target: x86_64-unknown-linux-gnu Thread model: posix InstalledDir: /llvmroot/bin \u0026#34;/llvmroot/bin/clang-7\u0026#34; \u0026#34;-cc1\u0026#34; \u0026#34;-triple\u0026#34; \u0026#34;x86_64-unknown-linux-gnu\u0026#34; \u0026#34;-emit-llvm-bc\u0026#34; \u0026#34;-emit-llvm-uselists\u0026#34; \u0026#34;-disable-free\u0026#34; \u0026#34;-main-file-name\u0026#34; \u0026#34;hello.c\u0026#34; \u0026#34;-mrelocation-model\u0026#34; \u0026#34;static\u0026#34; \u0026#34;-mthread-model\u0026#34; \u0026#34;posix\u0026#34; \u0026#34;-fmath-errno\u0026#34; \u0026#34;-masm-verbose\u0026#34; \u0026#34;-mconstructor-aliases\u0026#34; \u0026#34;-munwind-tables\u0026#34; \u0026#34;-fuse-init-array\u0026#34; \u0026#34;-target-cpu\u0026#34; \u0026#34;x86-64\u0026#34; \u0026#34;-dwarf-column-info\u0026#34; \u0026#34;-debugger-tuning=gdb\u0026#34; \u0026#34;-momit-leaf-frame-pointer\u0026#34; \u0026#34;-coverage-notes-file\u0026#34; \u0026#34;/home/test/playground/hello.gcno\u0026#34; \u0026#34;-resource-dir\u0026#34; \u0026#34;/llvmroot/lib/clang/7.0.0\u0026#34; \u0026#34;-internal-isystem\u0026#34; \u0026#34;/usr/local/include\u0026#34; \u0026#34;-internal-isystem\u0026#34; \u0026#34;/llvmroot/lib/clang/7.0.0/include\u0026#34; \u0026#34;-internal-externc-isystem\u0026#34; \u0026#34;/usr/include/x86_64-linux-gnu\u0026#34; \u0026#34;-internal-externc-isystem\u0026#34; \u0026#34;/include\u0026#34; \u0026#34;-internal-externc-isystem\u0026#34; \u0026#34;/usr/include\u0026#34; \u0026#34;-O2\u0026#34; \u0026#34;-fdebug-compilation-dir\u0026#34; \u0026#34;/home/test/playground\u0026#34; \u0026#34;-ferror-limit\u0026#34; \u0026#34;19\u0026#34; \u0026#34;-fmessage-length\u0026#34; \u0026#34;189\u0026#34; \u0026#34;-fobjc-runtime=gcc\u0026#34; \u0026#34;-fdiagnostics-show-option\u0026#34; \u0026#34;-fcolor-diagnostics\u0026#34; \u0026#34;-vectorize-loops\u0026#34; \u0026#34;-vectorize-slp\u0026#34; \u0026#34;-o\u0026#34; \u0026#34;hello.bc\u0026#34; \u0026#34;-x\u0026#34; \u0026#34;c\u0026#34; \u0026#34;hello.c\u0026#34; \u0026#34;-faddrsig\u0026#34; You can see that clang is calling the internal -cc1 interface. Though said to be modular, -cc1 is not further calling the opt optimizer, but consuming the -O2 option itself. In fact the LLVM IR codegen is built into the -cc1 as a library. You can pass arguments to the codegen after the switch -mllvm, and using -debug-pass you can see the information of passes executed:\n$ clang -mllvm -debug-pass=Arguments hello.c -O2 -c -o hello.bc -emit-llvm Pass Arguments: -tti -targetlibinfo -tbaa -scoped-noalias -assumption-cache-tracker -verify -ee-instrument -simplifycfg -domtree -sroa -early-cse -lower-expect Pass Arguments: -tti -targetlibinfo -tbaa -scoped-noalias -assumption-cache-tracker -profile-summary-info -forceattrs -inferattrs -ipsccp -called-value-propagation -globalopt -domtree -mem2reg -deadargelim -domtree -basicaa -aa -loops -lazy-branch-prob -lazy-block-freq -opt-remark-emitter -instcombine -simplifycfg -basiccg -globals-aa -prune-eh -inline -functionattrs -domtree -sroa -basicaa -aa -memoryssa -early-cse-memssa -basicaa -aa -lazy-value-info -jump-threading -correlated-propagation -simplifycfg -domtree -basicaa -aa -loops -lazy-branch-prob -lazy-block-freq -opt-remark-emitter -instcombine -libcalls-shrinkwrap -loops -branch-prob -block-freq -lazy-branch-prob -lazy-block-freq -opt-remark-emitter -pgo-memop-opt -basicaa -aa -loops -lazy-branch-prob \u0026lt;...\u0026gt; Pass Arguments: -targetlibinfo -domtree -loops -branch-prob -block-freq Pass Arguments: -targetlibinfo -domtree -loops -branch-prob -block-freq Pass Arguments: -tti So you see\u0026hellip; there are so many passes, and there are so many rounds of passes!\nIf you look into the source of clang, you\u0026rsquo;ll see that all it is doing upon a *.c file is handled inside the clang::ParseAST function, defined at lib/Parse/ParseAST.cpp:114. Through BackendConsumer::HandleTopLevelDecl, each item defined in the source file is translated into IR, if -emit-llvm is used, and through BackendConsumer::HandleTranslationUnit, the IR is optimized and printed. Passes are directly called in EmitAssemblyHelper::EmitAssembly, and here we can see that different rounds of passes stand for per-function round, per-module round, and code-gen round, respectively. Thus you cannot append all the output by -debug-pass to an opt run \u0026ndash; it will not work.\nWe compared the IR generated under different optimization level before going through all those passes, and we found that they were the same \u0026ndash; no optimizations done in the frontend.\nPut off optimizations Back to our topic. Regretfully we found that making clear about the pass running is not directly helpful, though interesting. Then what is that preventing the optimization? Maybe some metadata?\nWe examined the IR code again, and found out that there\u0026rsquo;s a function attribute called optnone, like this:\ndefine dso_local i32 @main() #0 { ... } attributes #0 = { noinline nounwind optnone uwtable ... After manually removing this attribute, the optimization now works. If manual modification is not acceptable, -Xclang -disable-O0-optnone is to the rescue.\nOne more thing. If we are using a higher optimization level, like -O2, can we simply put off the execution of all the passes? Yeah, use -Xclang -disable-llvm-passes.\nZero out the stack Another interesting task is that, how to safely zero out the stack in clang. In C11, there is memset_s, a safe memory-set operation that will not get optimized. However, it is optional, and not included in clang. But there are other chances.\nAs memset is in fact an internal function in LLVM, it could be created using a dedicated interface, i.e. IRBuilder::CreateMemSet. There is a volatile argument, with no explanation here. Well, all memory-write operations in LLVM could be marked as volatile so that it will not get optimized, and memset is just another case.\nWell, LLVM is great, offering so many possibilities. I just hope there could be better documentation :)\n"},{"id":4,"href":"/posts/hello-world/","title":"Hello World","section":"Blog","content":"Hi, this is Tantalus. I\u0026rsquo;m going to write about my life and my explorations. Cheers!\n"}]